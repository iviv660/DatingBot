package internal

import (
	userpb "app/user/proto"
	"context"
	"fmt"
	"io"
	"log"
	"sync"
	"time"
)

type ReplyKind int

const (
	ReplyNone ReplyKind = iota
	ReplyMenu
	ReplyGender
	ReplyBrowse
)

type Output struct {
	Text        string
	PhotoString string
	Kind        ReplyKind
}

type state int

const (
	stIdle state = iota
	stAskName
	stAskAge
	stAskCity
	stAskGender
	stAskDesc
	stAskPhoto
	stMenu
	stBrowsing
)

type session struct {
	State         state
	Draft         draftProfile
	Candidates    []int64
	CurrentTarget int64
	UpdatedAt     time.Time
}

type draftProfile struct {
	Name        string
	Age         int32
	City        string
	Gender      string
	Description string
	PhotoString string
}

type Core struct {
	users UserClient
	match MatchClient

	mu       sync.RWMutex
	sessions map[int64]*session
}

func NewCore(users UserClient, match MatchClient) *Core {
	return &Core{
		users:    users,
		match:    match,
		sessions: make(map[int64]*session),
	}
}

func (c *Core) get(chatID int64) *session {
	c.mu.RLock()
	s := c.sessions[chatID]
	c.mu.RUnlock()
	if s == nil {
		s = &session{State: stIdle, UpdatedAt: time.Now()}
		c.mu.Lock()
		c.sessions[chatID] = s
		c.mu.Unlock()
	}
	return s
}

func (c *Core) reset(chatID int64) {
	c.mu.Lock()
	delete(c.sessions, chatID)
	c.mu.Unlock()
}

func (c *Core) OnStart(ctx context.Context, chatID int64) (Output, error) {
	u, err := c.users.GetByTelegramID(ctx, chatID)
	if err != nil {
		log.Printf("core: GetByTelegramID: %v", err)
	}

	s := c.get(chatID)
	if u == nil {
		s.State = stAskName
		s.Draft = draftProfile{}
		s.UpdatedAt = time.Now()
		return Output{Text: "–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º –∞–Ω–∫–µ—Ç—É.\n–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"}, nil
	}

	s.State = stMenu
	s.UpdatedAt = time.Now()
	return Output{
		Text: fmt.Sprintf(
			"%s, %d, %s ‚Äî %s\n\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:\n1. –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã üöÄ\n2. –ú–æ—è –∞–Ω–∫–µ—Ç–∞ üì±\n3. –ò–∑–º–µ–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É ‚úèÔ∏è",
			u.GetUsername(), u.GetAge(), u.GetLocation(), u.GetDescription(),
		),
		Kind:        ReplyMenu,
		PhotoString: u.GetPhotoUrl(),
	}, nil
}

func (c *Core) OnText(ctx context.Context, chatID int64, text string) (Output, error) {
	s := c.get(chatID)
	switch s.State {
	case stAskName:
		s.Draft.Name = text
		s.State = stAskAge
		s.UpdatedAt = time.Now()
		return Output{Text: "–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ª–µ—Ç?"}, nil
	case stAskAge:
		var age int32
		_, err := fmt.Sscanf(text, "%d", &age)
		if err != nil || age <= 0 {
			return Output{Text: "–í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º. –í–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç."}, nil
		}
		s.Draft.Age = age
		s.State = stAskCity
		s.UpdatedAt = time.Now()
		return Output{Text: "–ì–¥–µ —Ç—ã –∂–∏–≤—ë—à—å? –£–∫–∞–∂–∏ –≥–æ—Ä–æ–¥."}, nil
	case stAskCity:
		s.Draft.City = text
		s.State = stAskGender
		s.UpdatedAt = time.Now()
		return Output{Text: "–í—ã–±–µ—Ä–∏ –ø–æ–ª:", Kind: ReplyGender}, nil
	case stAskGender:
		if text != "–ü–∞—Ä–µ–Ω—å" && text != "–î–µ–≤—É—à–∫–∞" {
			return Output{Text: "–£–∫–∞–∂–∏ –°–≤–æ–π –ø–æ–ª", Kind: ReplyGender}, nil
		}
		s.Draft.Gender = text
		s.State = stAskDesc
		s.UpdatedAt = time.Now()
		return Output{Text: "–ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏ —Å–µ–±—è (–∏–Ω—Ç–µ—Ä–µ—Å—ã, —á—Ç–æ –∏—â–µ—à—å)."}, nil
	case stAskDesc:
		s.Draft.Description = text
		s.State = stAskPhoto
		s.UpdatedAt = time.Now()
		return Output{Text: "–ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ –¥–ª—è –∞–Ω–∫–µ—Ç—ã (–æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)."}, nil
	case stMenu:
		switch text {
		case "1":
			return c.startBrowsing(ctx, chatID)
		case "2":
			return c.showProfile(ctx, chatID)
		case "3":
			s.State = stAskName
			s.Draft = draftProfile{}
			s.UpdatedAt = time.Now()
			return Output{Text: "–û–∫, –æ–±–Ω–æ–≤–∏–º –∞–Ω–∫–µ—Ç—É. –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"}, nil
		default:
			return Output{Text: "–í—ã–±–µ—Ä–∏ –ø—É–Ω–∫—Ç –º–µ–Ω—é: 1 (—Å–º–æ—Ç—Ä–µ—Ç—å), 2 (–º–æ—è –∞–Ω–∫–µ—Ç–∞), 3 (–∏–∑–º–µ–Ω–∏—Ç—å).", Kind: ReplyMenu}, nil
		}
	case stBrowsing:
		return Output{Text: "–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏: ‚ù§ / üëé / üí§", Kind: ReplyBrowse}, nil
	default:
		s.State = stAskName
		return Output{Text: "–î–∞–≤–∞–π –Ω–∞—á–Ω—ë–º —Å –Ω–∞—á–∞–ª–∞. –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"}, nil
	}
}

func (c *Core) OnPhoto(ctx context.Context, chatID int64, photo []byte) (Output, error) {
	s := c.get(chatID)
	if s.State != stAskPhoto {
		return Output{Text: "–§–æ—Ç–æ —Å–µ–π—á–∞—Å –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è. –ò—Å–ø–æ–ª—å–∑—É–π –º–µ–Ω—é."}, nil
	}
	// s.Draft.PhotoBytes = photo // ‚Üê –£–î–ê–õ–ò–¢–¨, —Ç–∞–∫–æ–≥–æ –ø–æ–ª—è –±–æ–ª—å—à–µ –Ω–µ—Ç

	u := &userpb.User{
		TelegramId:  chatID,
		Username:    s.Draft.Name,
		Age:         s.Draft.Age,
		Gender:      s.Draft.Gender,
		Location:    s.Draft.City,
		Description: s.Draft.Description,
		IsVisible:   true,
	}
	created, err := c.users.Create(ctx, u)
	if err != nil {
		log.Printf("core: Create user: %v", err)
		return Output{Text: "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑."}, nil
	}

	updated := created
	if len(photo) > 0 {
		if u2, err := c.users.UpdatePhoto(ctx, created.GetId(), bytesReader(photo)); err != nil {
			log.Printf("core: UpdatePhoto: %v", err)
		} else if u2 != nil {
			updated = u2
		}
	}

	s.State = stMenu
	s.Draft = draftProfile{}
	s.UpdatedAt = time.Now()

	return Output{
		Text: fmt.Sprintf(
			"%s, %d, %s ‚Äî %s\n\n–ê–Ω–∫–µ—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –ß—Ç–æ –¥–∞–ª—å—à–µ?\n1. –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã üöÄ\n2. –ú–æ—è –∞–Ω–∫–µ—Ç–∞ üì±\n3. –ò–∑–º–µ–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É ‚úèÔ∏è",
			updated.GetUsername(), updated.GetAge(), updated.GetLocation(), updated.GetDescription(),
		),
		Kind:        ReplyMenu,
		PhotoString: updated.GetPhotoUrl(),
	}, nil
}

func (c *Core) OnCallback(ctx context.Context, chatID int64, action string) (Output, error) {
	s := c.get(chatID)
	if s.State == stAskGender && (action == "gender_male" || action == "gender_female") {
		if action == "gender_male" {
			s.Draft.Gender = "–ü–∞—Ä–µ–Ω—å"
		} else {
			s.Draft.Gender = "–î–µ–≤—É—à–∫–∞"
		}
		s.State = stAskDesc
		s.UpdatedAt = time.Now()
		return Output{Text: "–ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏ —Å–µ–±—è."}, nil
	}
	if s.State == stBrowsing {
		switch action {
		case "like":
			if s.CurrentTarget == 0 {
				return Output{Text: "–ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –±–æ–ª—å—à–µ –Ω–µ—Ç.", Kind: ReplyMenu}, nil
			}
			if err := c.match.Like(ctx, chatID, s.CurrentTarget, true); err != nil {
				log.Printf("core: Like: %v", err)
			}
			return c.nextCandidate(ctx, chatID)
		case "dislike":
			if err := c.match.Like(ctx, chatID, s.CurrentTarget, false); err != nil {
				log.Printf("core: Dislike: %v", err)
			}
			return c.nextCandidate(ctx, chatID)
		case "sleep":
			s.State = stMenu
			s.UpdatedAt = time.Now()
			return Output{
				Text: "–û–∫, –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é.\n1. –°–º–æ—Ç—Ä–µ—Ç—å –∞–Ω–∫–µ—Ç—ã üöÄ\n2. –ú–æ—è –∞–Ω–∫–µ—Ç–∞ üì±\n3. –ò–∑–º–µ–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É ‚úèÔ∏è",
				Kind: ReplyMenu,
			}, nil
		}
	}
	return Output{Text: "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ."}, nil
}

func (c *Core) startBrowsing(ctx context.Context, chatID int64) (Output, error) {
	u, err := c.users.GetByTelegramID(ctx, chatID)
	if err != nil {
		return Output{}, err
	}
	if u == nil {
		s := c.get(chatID)
		s.State = stAskName
		return Output{Text: "–ü–æ—Ö–æ–∂–µ, –∞–Ω–∫–µ—Ç—ã –Ω–µ—Ç. –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"}, nil
	}
	cands, err := c.match.GetCandidates(ctx, u.GetId())
	if err != nil {
		return Output{}, err
	}
	if len(cands) == 0 {
		return Output{Text: "–ü–æ–∫–∞ –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –∞–Ω–∫–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.", Kind: ReplyMenu}, nil
	}
	s := c.get(chatID)
	s.Candidates = s.Candidates[:0]
	for _, cand := range cands {
		s.Candidates = append(s.Candidates, cand.GetTelegramId())
	}
	s.State = stBrowsing
	s.UpdatedAt = time.Now()
	return c.nextCandidate(ctx, chatID)
}

func (c *Core) nextCandidate(ctx context.Context, chatID int64) (Output, error) {
	s := c.get(chatID)
	if len(s.Candidates) == 0 {
		s.State = stMenu
		return Output{Text: "–ê–Ω–∫–µ—Ç—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é.", Kind: ReplyMenu}, nil
	}
	last := s.Candidates[len(s.Candidates)-1]
	s.Candidates = s.Candidates[:len(s.Candidates)-1]
	s.CurrentTarget = last
	s.UpdatedAt = time.Now()

	target, err := c.users.GetByTelegramID(ctx, last)
	if err != nil || target == nil {
		return Output{Text: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞. –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–µ–≥–æ‚Ä¶"}, nil
	}

	caption := fmt.Sprintf("%s, %d, %s ‚Äî %s",
		target.GetUsername(), target.GetAge(), target.GetLocation(), target.GetDescription())

	return Output{
		Text:        caption,
		Kind:        ReplyBrowse,
		PhotoString: target.GetPhotoUrl(),
	}, nil
}

func (c *Core) showProfile(ctx context.Context, chatID int64) (Output, error) {
	u, err := c.users.GetByTelegramID(ctx, chatID)
	if err != nil {
		return Output{}, err
	}
	if u == nil {
		return Output{Text: "–ê–Ω–∫–µ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º! –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"}, nil
	}
	return Output{
		Text: fmt.Sprintf("–¢–≤–æ—è –∞–Ω–∫–µ—Ç–∞: %s, %d, %s ‚Äî %s",
			u.GetUsername(), u.GetAge(), u.GetLocation(), u.GetDescription()),
		Kind:        ReplyMenu,
		PhotoString: u.GetPhotoUrl(),
	}, nil
}

type byteReader struct{ b []byte }

func bytesReader(b []byte) *byteReader { return &byteReader{b: b} }

func (r *byteReader) Read(p []byte) (int, error) {
	if len(r.b) == 0 {
		return 0, io.EOF
	}
	n := copy(p, r.b)
	r.b = r.b[n:]
	return n, nil
}
